<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Scattergraph 3.0 - A creative image scattering tool by Therefore, Nul" />
  <title>Scattergraph 3.0 by Therefore, Nul</title>
  <link href="fonts/fonts.css" rel="stylesheet">
  <link href="https://fonts.cdnfonts.com/css/ocr-a-std" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
      background: #000;
    }
    #selector, #canvasView {
      width: 100vw;
      height: 100vh;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    #selector {
      position: fixed;
      top: 90px; /* Increased height of the toolbar */
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
      opacity: 0;
      z-index: 1;
      height: calc(100vh - 90px); /* Subtract increased toolbar height */
    }

    #selector::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: -1;
    }

    /* Global scanline overlay */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        transparent 50%,
        rgba(0, 0, 0, 0.25) 50.5%,
        transparent 51%
      );
      background-size: 100% 4px;
      pointer-events: none;
      z-index: 9999;
      animation: scanline 8s linear infinite;
      opacity: 0.5;
    }

    .canvas-view body::after {
      display: none;
    }

    /* Speed up glitch animations */
    @keyframes glitch-anim-1 {
      0%, 100% { 
        opacity: 1;
        transform: translate(0);
        clip-path: inset(0 0 0 0);
      }
      20% { 
        opacity: 0.8;
        transform: translate(-2px, 1px);
        clip-path: inset(20% 0 30% 0);
      }
      40% {
        transform: translate(2px, -1px);
        clip-path: inset(60% 0 10% 0);
      }
      60% { 
        transform: translate(-1px, 2px);
        clip-path: inset(40% 0 40% 0);
      }
      80% {
        transform: translate(1px, -2px);
        clip-path: inset(80% 0 5% 0);
      }
    }

    @keyframes glitch-anim-2 {
      0%, 100% { 
        opacity: 0.9;
        transform: translate(0);
        clip-path: inset(0 0 0 0);
      }
      25% {
        transform: translate(2px, 2px);
        clip-path: inset(30% 0 40% 0);
      }
      50% {
        transform: translate(-2px, -2px);
        clip-path: inset(50% 0 20% 0);
      }
      75% {
        transform: translate(1px, -1px);
        clip-path: inset(70% 0 10% 0);
      }
    }

    /* Additional glitch variants for thumbnails */
    @keyframes glitch-anim-3 {
      0%, 100% { 
        opacity: 0.95;
        transform: translate(0);
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      }
      20% {
        clip-path: polygon(0 15%, 100% 15%, 100% 30%, 0 30%);
      }
      40% {
        clip-path: polygon(0 45%, 100% 45%, 100% 65%, 0 65%);
      }
      60% {
        clip-path: polygon(0 75%, 100% 75%, 100% 85%, 0 85%);
      }
    }

    @keyframes glitch-anim-4 {
      0%, 100% { 
        opacity: 0.9;
        transform: translate(0);
      }
      33% {
        transform: translate(3px, -2px) skewX(2deg);
      }
      66% {
        transform: translate(-3px, 1px) skewX(-2deg);
      }
    }

    @keyframes glitch-anim-5 {
      0%, 100% { 
        opacity: 0.85;
        filter: none;
      }
      50% {
        filter: hue-rotate(90deg) saturate(150%);
      }
    }

    /* Speed up header glitch animation */
    /* .branding h1::before {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 2px;
      text-shadow: 2px 0 #ef3b39;
      animation: glitch-anim-1 1s infinite steps(2);
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
    }

    .branding h1::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: -2px;
      text-shadow: -2px 0 #12e2dc;
      animation: glitch-anim-2 1s infinite steps(2);
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
    } */

    /* Update button colors */
    #clearButton {
      background: #ef3b39;
    }
    #clearButton:hover {
      background: #d32f2f;
    }

    #toggleSelectButton {
      background: #12e2dc;
    }
    #toggleSelectButton:hover {
      background: #10c5c0;
    }

    #saveButton {
      background: #ece83e;
      color: #000;
    }
    #saveButton:hover {
      background: #d6d235;
    }

    /* VHS Scanline effect */
    @keyframes scanline {
      0% {
        transform: translateY(-100%);
      }
      100% {
        transform: translateY(100%);
      }
    }

    /* VHS tracking distortion */
    @keyframes tracking {
      0% {
        transform: translateY(0);
      }
      100% {
        transform: translateY(2px);
      }
    }

    /* Toolbar with wavy border */
    #toolbar {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      background: #000000;
      padding: 25px 15px; /* Increased vertical padding */
      z-index: 2000;
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 20px;
      border-bottom: 2px solid;
      border-image: linear-gradient(90deg, 
        transparent 0%,
        #ef3b39 15%,
        #12e2dc 50%,
        #ece83e 85%,
        transparent 100%
      ) 1;
      min-height: 40px; /* Ensure minimum height */
    }

    #toolbar::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, 
        transparent 0%,
        #ef3b39 15%,
        #12e2dc 50%,
        #ece83e 85%,
        transparent 100%
      );
      clip-path: path('M0,1 Q25,0 50,1 T100,1');
      animation: waveMove 10s linear infinite;
    }

    @keyframes waveMove {
      0% { background-position: 0 0; }
      100% { background-position: 100px 0; }
    }

    /* Branding styles */
    .branding {
      flex: 0 0 auto;
      margin-right: 20px;
    }

    .branding h1 {
      font-family: 'BW Stretch', sans-serif;
      color: #fff;
      position: relative;
      display: inline-block;
      white-space: nowrap;
      font-size: 24px;
      line-height: 1.2;
      margin: 0;
    }

    .glitch-text {
      position: relative;
      display: inline-block;
    }

    .glitch-text::before,
    .glitch-text::after {
      font-family: 'BW Stretch', sans-serif;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      pointer-events: none;
    }

    .glitch-text::before {
      content: "Scatt<span class='alt-e'>e</span>rgraph";
      text-shadow: 2px 0 #ef3b39;
      animation: vhsGlitch 8s steps(1) infinite;
      animation-delay: -4s;
    }

    .glitch-text::after {
      content: "Scatt<span class='alt-e'>e</span>rgraph";
      text-shadow: -2px 0 #12e2dc;
      animation: vhsGlitch 8s steps(1) infinite;
      animation-delay: -2s;
    }

    @keyframes vhsGlitch {
      0%, 85%, 100% { opacity: 0; transform: translate(0); }
      87% { opacity: 1; transform: translate(-2px, 0); }
      88% { opacity: 1; transform: translate(2px, 0); }
      89% { opacity: 1; transform: translate(-1px, 0); }
      90% { opacity: 1; transform: translate(1px, 0); }
      91% { opacity: 0; transform: translate(0); }
    }

    /* Image selection grid styles */
    .image-container {
      position: relative;
      width: 250px;
      height: 250px;
      padding: 5px;
      border-radius: 0;
      overflow: hidden;
      background: transparent;
      transition: background-color 0.1s ease;
      z-index: 2;
    }

    .serial-number {
      position: absolute;
      bottom: 25%;
      left: 0;
      right: 0;
      text-align: center;
      font-family: 'OCR A Std', monospace;
      color: white;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 3;
      background: rgba(0,0,0,0.5);
      padding: 4px;
    }

    .image-option {
      width: 100%;
      height: 100%;
      object-fit: contain;
      cursor: pointer;
      transition: transform 0.1s ease;
      position: relative;
      z-index: 2;
    }

    /* Checkerboard hover effect */
    .image-container:nth-child(odd):hover {
      background-color: rgba(239, 59, 57, 1); /* Brand red */
    }

    .image-container:nth-child(even):hover {
      background-color: rgba(18, 226, 220, 1); /* Brand teal */
    }

    /* Selected state */
    .image-container:has(.selected) {
      background-color: rgba(236, 232, 62, 1); /* Brand volt */
    }

    .image-option:hover {
      transform: scale(1.05);
    }

    /* Remove old glitch effects */
    .glitch-before,
    .glitch-after {
      display: none;
    }

    /* Update header styles */
    @font-face {
      font-family: 'BW Stretch';
      src: url('fonts/BWStretchRegular.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }

    /* Target only the 'e' character in Scattergraph */
    .branding h1 e {
      font-feature-settings: "salt";
    }

    /* Superscript styles */
    .version-number {
      font-size: 0.6em;
      vertical-align: super;
      margin-left: 2px;
    }

    .branding h2 {
      color: rgba(255, 255, 255, 0.8);
      white-space: nowrap;
      margin: 0;
      font-size: 16px;
      font-weight: normal;
      font-family: 'Adobe Garamond Pro', 'EB Garamond', Garamond, serif;
    }

    .branding a {
      color: #12e2dc;
      text-decoration: none;
      position: relative;
      transition: color 0.3s ease;
      font-style: italic;
    }

    .branding a:hover {
      color: #ef3b39;
      text-decoration: none;
    }

    /* Enhanced tooltip styles */
    [data-tooltip] {
      position: relative;
      cursor: pointer;
    }

    [data-tooltip]:before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 5px 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      z-index: 3000;
      pointer-events: none;
    }

    [data-tooltip]:hover:before {
      opacity: 1;
      visibility: visible;
    }

    /* Loading styles */
    #loadingOverlay {
      position: fixed;
      inset: 0;
      z-index: 10000;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 0.8s ease-out;
      overflow: hidden;
    }

    /* Fade in content behind loading screen */
    #selector, #toolbar {
      opacity: 0;
      transition: opacity 0.3s ease-in;
    }

    #selector.loaded, #toolbar.loaded {
      opacity: 1;
    }

    .loading-container {
      --s: 40px;
      --b: 18px;
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      filter: blur(7px) contrast(20);
      background: #000;
      mix-blend-mode: screen;
      opacity: 0;
      transition: opacity 1s ease-in;
    }

    .loading-container.animate {
      opacity: 1;
    }

    .loading-container::before,
    .loading-container::after {
      content: "";
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, var(--_c,#ef3b39) 0 0) var(--_p, -100vw) 50% / 100% 100% no-repeat;
      --_g: calc(-.45*var(--s)), #0000 calc(99% - var(--b)),#000 calc(101% - var(--b)) 99%,#0000 101%;
      --_s: calc(4*var(--s)) calc(3*var(--s));
      --_r: calc(1.096*var(--s) + var(--b)/2);
      -webkit-mask:
        radial-gradient(var(--_r) at left 50% bottom var(--_g)) 
          calc(50% - 2*var(--s)) calc(50% - 3*var(--s)/2 + var(--_o,0px))/var(--_s),
        radial-gradient(var(--_r) at left 50% top    var(--_g)) 
          50%                    calc(50% + 3*var(--s)/2 + var(--_o,0px))/var(--_s);
      animation: wave-left 8s infinite linear;
      animation-play-state: paused;
      opacity: 0;
      transition: opacity 0.5s ease-in;
    }

    .loading-container.animate::before,
    .loading-container.animate::after {
      opacity: 1;
      animation-play-state: running;
    }

    .loading-container::after {
      --_c: #12e2dc;
      --_o: calc(3*var(--s)/2);
      --_p: 100vw;
      animation: wave-right 8s infinite linear;
      animation-play-state: paused;
    }

    @keyframes wave-left {
      0% { background-position: -100vw 50%; }
      100% { background-position: 100vw 50%; }
    }

    @keyframes wave-right {
      0% { background-position: 100vw 50%; }
      100% { background-position: -100vw 50%; }
    }

    #loadingText {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-family: 'OCR A Std', monospace;
      font-size: 72px;
      text-align: center;
      z-index: 10001;
      background: none;
      padding: 40px;
      pointer-events: none;
    }

    /* Hide selector content while loading */
    #selector {
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    #selector.loaded {
      opacity: 1;
    }

    /* Hide buttons until loaded */
    .toolbar-buttons {
      display: flex;
      height: 66px;
      gap: 10px;
      margin: 0;
      align-items: center;
      opacity: 1;
      margin-left: auto; /* Push buttons to the right */
    }

    .toolbar-buttons.loaded {
      opacity: 1;
    }

    .control-group label {
      color: #fff;
      font-family: 'OCR A Std', monospace;
      text-transform: uppercase;
      font-size: 14px;
      cursor: pointer;
      margin-bottom: -4px;
    }

    /* Slider base styles */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 24px;
      background: transparent;
      padding: 0 2px;
      box-sizing: border-box;
    }

    /* Track styles */
    input[type="range"]::-webkit-slider-runnable-track {
      height: 24px;
      border-radius: 12px;
      border: none;
      padding: 2px;
    }

    input[type="range"]#scaleMin::-webkit-slider-runnable-track,
    input[type="range"]#scaleMax::-webkit-slider-runnable-track {
      background-color: #ef3b39;
    }

    input[type="range"]#rotationRange::-webkit-slider-runnable-track {
      background-color: #12e2dc;
    }

    input[type="range"]#wobbleRange::-webkit-slider-runnable-track {
      background-color: #ece83e;
    }

    /* Thumb styles */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 24px;
      width: 24px;
      border-radius: 50%;
      background: #000000;
      cursor: pointer;
      margin-top: -2px; /* Centers the thumb on the track */
    }

    input[type="range"]#scaleMin::-webkit-slider-thumb,
    input[type="range"]#scaleMax::-webkit-slider-thumb {
      border: 2px solid #ef3b39;
    }

    input[type="range"]#rotationRange::-webkit-slider-thumb {
      border: 2px solid #12e2dc;
    }

    input[type="range"]#wobbleRange::-webkit-slider-thumb {
      border: 2px solid #ece83e;
    }

    /* Firefox styles */
    input[type="range"]::-moz-range-track {
      height: 24px;
      border-radius: 12px;
      border: none;
      padding: 2px;
    }

    input[type="range"]#scaleMin::-moz-range-track,
    input[type="range"]#scaleMax::-moz-range-track {
      background-color: #ef3b39;
    }

    input[type="range"]#rotationRange::-moz-range-track {
      background-color: #12e2dc;
    }

    input[type="range"]#wobbleRange::-moz-range-track {
      background-color: #ece83e;
    }

    input[type="range"]::-moz-range-thumb {
      height: 24px;
      width: 24px;
      border-radius: 50%;
      background: #000000;
      cursor: pointer;
    }

    input[type="range"]#scaleMin::-moz-range-thumb,
    input[type="range"]#scaleMax::-moz-range-thumb {
      border: 2px solid #ef3b39;
    }

    input[type="range"]#rotationRange::-moz-range-thumb {
      border: 2px solid #12e2dc;
    }

    input[type="range"]#wobbleRange::-moz-range-thumb {
      border: 2px solid #ece83e;
    }

    .slider-container {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    /* Add styles for directory headers */
    .directory-header {
      width: 250px;
      height: 250px;
      padding: 5px;
      margin: 0;
      font-size: 24px;
      color: #fff;
      font-weight: normal;
      font-family: 'OCR A Std', monospace;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      background: #000;
      border: none;
      position: relative;
      transition: background-color 0.1s ease;
      cursor: pointer;
    }

    /* Match the checkerboard hover effect */
    .directory-section:nth-child(odd) .directory-header {
      background-color: rgba(239, 59, 57, 0.2); /* Brand red with low opacity */
    }

    .directory-section:nth-child(even) .directory-header {
      background-color: rgba(18, 226, 220, 0.2); /* Brand teal with low opacity */
    }

    .directory-section:nth-child(odd) .directory-header:hover {
      background-color: rgba(239, 59, 57, 1); /* Full opacity brand red */
    }

    .directory-section:nth-child(even) .directory-header:hover {
      background-color: rgba(18, 226, 220, 1); /* Full opacity brand teal */
    }

    /* Directory section styles */
    .directory-section {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 20px;
      margin-bottom: 20px;
      justify-content: center;
      position: relative;
      z-index: 2;
    }

    /* Remove margin-top from directory sections */
    .directory-section:first-child {
      margin-top: 0;
      padding-top: 20px;
    }

    .branding {
      flex: 0 0 auto;
      margin-right: 20px;
    }

    .branding h1 {
      margin: 0;
      font-size: 32px;
      letter-spacing: .5px;
      line-height: 1.2;
      text-transform: uppercase;
    }

    .controls-section {
      display: flex;
      align-items: center;
      gap: 20px;
      flex: 0 1 auto; /* Don't grow, allow shrink, auto basis */
      margin: auto;
    }

    .control-group {
      margin: 0;
      padding: 0;
      border: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .scale-sliders {
      display: flex;
      gap: 20px;
      width: 100%;
    }

    .value-label {
      font-size: 12px;
      color: #fff;
      text-align: center;
      font-family: 'OCR A Std', monospace;
      text-transform: uppercase;
      margin-top: -4px;
    }

    #selector {
      padding-top: 0;
    }

    #canvasView {
      padding-top: 65px;  /* Make room for the toolbar */
    }

    /* Hide canvas-specific controls on selector screen */
    .canvas-controls {
      display: none;
    }

    .canvas-view .canvas-controls {
      display: flex;
    }

    button {
      padding: 8px 15px;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      min-width: 100px;
      height: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      font-family: 'OCR A Std', monospace;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 1;
      margin: 0; /* Reset margin */
    }

    button:hover {
      background: #45a049;
    }

    #startButton {
      background: #ece83e;
      color: #000;
    }

    #startButton:hover {
      background: #d6d235;
    }

    canvas {
      display: block;
    }

    #cursorImage {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      transform-origin: center;
      transform: translate(-50%, -50%) scale(1);
    }

    #canvasView {
      position: relative;
      z-index: 1;
    }

    #saveButton {
      background: #ece83e;
      color: #000;
      margin: 0;
    }

    #saveButton:hover {
      background: #d6d235;
    }

    #clearButton {
      background: #ef3b39;
    }

    #clearButton:hover {
      background: #d32f2f;
    }

    #toggleSelectButton {
      background: #12e2dc;
    }

    #toggleSelectButton:hover {
      background: #10c5c0;
    }

    #randomizeBtn {
      background: #12e2dc;
    }

    #randomizeBtn:hover {
      background: #10c5c0;
    }

    #clearSelectionBtn {
      background: #ef3b39;
    }

    #clearSelectionBtn:hover {
      background: #d32f2f;
    }

    .selector-controls,
    .canvas-controls {
      display: none;
      margin: 0;
    }

    body:not(.canvas-view) .selector-controls {
      display: flex;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: #999;
    }

    button:disabled:hover {
      background: #999;
    }

    /* Add styles for the new Select All button */
    #selectAllBtn {
      background: #12e2dc;
    }

    #selectAllBtn:hover {
      background: #10c5c0;
    }

    /* Directory header active state */
    .directory-header {
      position: relative;
      transition: background-color 0.3s ease;
    }

    .directory-header.all-selected {
      background-color: rgba(18, 226, 220, 0.8) !important; /* Use the teal color */
    }

    .directory-header.all-selected::after {
      content: '✓';
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      color: #000;
    }

    /* Add debug overlay styles */
    #serialOverlay {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.9);
      color: #12e2dc;
      font-family: 'OCR A Std', monospace;
      padding: 10px;
      font-size: 12px;
      z-index: 9998;
      max-height: 30vh;
      overflow-y: auto;
    }

    #serialOverlay.visible {
      display: block;
    }

    #serialOverlay pre {
      margin: 0;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="loadingOverlay">
    <div id="loadingText">Loading...</div>
    <div class="loading-container">
    </div>
  </div>

  <!-- Selection Grid -->
  <div id="selector">
    <!-- Removed randomize controls div -->
  </div>

  <!-- Toolbar -->
  <div id="toolbar">
    <div class="branding">
      <h1 data-text="Scatteeeergraph ³·⁰">Scatt<e>e</e>rgraph <span class="version-number">3.0</span></h1>
      <h2>by <a href="http://www.thfnul.com" target="_blank">Therefore, Nul</a></h2>
    </div>
    <div class="controls-section">
      <div class="control-group canvas-controls">
        <label for="scaleMin" data-tooltip="Adjust minimum scale (Q/Shift+Q to adjust)">Scale</label>
        <div class="scale-sliders">
          <div class="slider-container">
            <input type="range" id="scaleMin" min="0.1" max="1" step="0.1" value="0.4" data-tooltip="Minimum scale (Q to increase, Shift+Q to decrease)">
            <span class="value-label">Min: <span id="scaleMinValue">0.4</span></span>
          </div>
          <div class="slider-container">
            <input type="range" id="scaleMax" min="0.1" max="1" step="0.1" value="0.6" data-tooltip="Maximum scale (W to increase, Shift+W to decrease)">
            <span class="value-label">Max: <span id="scaleMaxValue">0.6</span></span>
          </div>
        </div>
      </div>
      
      <div class="control-group canvas-controls">
        <label for="rotationRange" data-tooltip="Adjust maximum rotation angle (A/Shift+A to adjust)">Rotation</label>
        <div class="slider-container">
          <input type="range" id="rotationRange" min="0" max="180" value="20" data-tooltip="Maximum rotation angle (A to increase, Shift+A to decrease)">
          <span class="value-label">±<span id="rotationValue">20</span>°</span>
        </div>
      </div>
      
      <div class="control-group canvas-controls">
        <label for="wobbleRange" data-tooltip="Adjust position offset (S/Shift+S to adjust)">Wobble</label>
        <div class="slider-container">
          <input type="range" id="wobbleRange" min="0" max="100" value="30" data-tooltip="Position offset in pixels (S to increase, Shift+S to decrease)">
          <span class="value-label">±<span id="wobbleValue">30</span>px</span>
        </div>
      </div>
    </div>

    <div class="toolbar-buttons">
      <button id="selectAllBtn" class="selector-controls" data-tooltip="Select all available images">Select All</button>
      <button id="clearSelectionBtn" class="selector-controls" data-tooltip="Remove all selected images">Clear Selection</button>
      <button id="randomizeBtn" class="selector-controls" data-tooltip="Select a random set of images">Randomize</button>
      <button id="startButton" class="selector-controls">START SCATTERGRAM ></button>
      <button id="clearButton" class="canvas-controls" data-tooltip="Remove all images from the canvas">Clear Canvas</button>
      <button id="toggleSelectButton" class="canvas-controls" data-tooltip="You can return to the selection screen to edit your scattergram brush">&lt; EDIT IMAGE SELECTION</button>
      <button id="saveButton" class="canvas-controls" data-tooltip="Save your entire canvas to a PNG in your downloads">Save Scattergram</button>
    </div>
  </div>

  <!-- Canvas View -->
  <div id="canvasView">
    <canvas id="paintCanvas"></canvas>
    <img id="cursorImage" />
  </div>

  <!-- Add debug overlay -->
  <div id="serialOverlay">
    <pre></pre>
  </div>

  <script>
    // === STATE ===
    let selectedImages = [];
    let isMouseDown = false;
    let isImageLocked = false;
    let lockedImage = null;
    let nextImageIndex = 0;
    let allFilenames = []; // Will be populated from server
    let scaleRange = { min: 0.4, max: 0.6 };
    let maxRotation = 20;
    let wobbleAmount = 30;
    let canvasHasContent = false; // Track if canvas has content

    // Add loading state tracking
    let loadedImages = 0;
    let totalImages = 0;

    // Add at the start of your script, after state variables
    const DEBUG = {
      skipLoadingAnimation: false,
      minLoadingTime: 7000,
      animationStartDelay: 100,
      showSerialOverlay: true,  // Toggle serial number tracking overlay
      trackInstanceCount: true   // Toggle instance counting
    };

    let loadingStartTime = Date.now();

    // Add to state variables section
    let usedSerials = new Map(); // Map of serial -> count
    
    // Add after existing state variables
    let dbInitialized = false;

    // Database initialization function
    async function initDatabase() {
      try {
        const response = await fetch('/api/init-db', { method: 'POST' });
        const result = await response.json();
        dbInitialized = result.success;
        console.log('Database initialized:', result.message);
      } catch (error) {
        console.error('Failed to initialize database:', error);
      }
    }

    // Function to format sequence number
    function formatSequenceNumber(num) {
      const length = Math.max(3, String(num).length);
      return String(num).padStart(length, '0');
    }

    // Function to format directory name
    function formatDirectoryName(dir) {
      return dir.split('-').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
    }

    // Function to check if all images in a section are selected
    function updateDirectoryHeaderState(section) {
      const header = section.querySelector('.directory-header');
      const images = section.querySelectorAll('.image-option');
      const allSelected = Array.from(images).every(img => img.classList.contains('selected'));
      
      if (allSelected) {
        header.classList.add('all-selected');
      } else {
        header.classList.remove('all-selected');
      }
    }

    // Function to select all images
    function selectAllImages() {
      const images = document.querySelectorAll('.image-option');
      const allSelected = Array.from(images).every(img => img.classList.contains('selected'));
      
      images.forEach(img => {
        if (allSelected) {
          // If all are selected, deselect all
          img.classList.remove('selected');
          selectedImages = selectedImages.filter(src => src !== img.src);
        } else {
          // If not all are selected, select all
          if (!img.classList.contains('selected')) {
            img.classList.add('selected');
            selectedImages.push(img.src);
          }
        }
      });

      // Update all directory headers
      document.querySelectorAll('.directory-section').forEach(section => {
        updateDirectoryHeaderState(section);
      });
      
      updateClearButtonStates();
    }

    // Function to create directory section
    function createDirectorySection(dirName) {
      const section = document.createElement('div');
      section.className = 'directory-section';
      
      const header = document.createElement('h3');
      header.className = 'directory-header';
      header.textContent = formatDirectoryName(dirName);
      
      // Add click handler for directory header
      header.addEventListener('click', () => {
        const images = section.querySelectorAll('.image-option');
        const allSelected = Array.from(images).every(img => img.classList.contains('selected'));
        const allImagesSelected = document.querySelectorAll('.image-option.selected').length === document.querySelectorAll('.image-option').length;
        
        images.forEach(img => {
          if (allImagesSelected) {
            // If all images everywhere are selected, only deselect this section
            img.classList.remove('selected');
            selectedImages = selectedImages.filter(src => src !== img.src);
          } else {
            // Normal toggle behavior for this section
            if (allSelected) {
              img.classList.remove('selected');
              selectedImages = selectedImages.filter(src => src !== img.src);
            } else {
              if (!img.classList.contains('selected')) {
                img.classList.add('selected');
                selectedImages.push(img.src);
              }
            }
          }
        });
        
        // Update all directory headers
        document.querySelectorAll('.directory-section').forEach(section => {
          updateDirectoryHeaderState(section);
        });
        
        updateClearButtonStates();
      });
      
      section.appendChild(header);
      selector.appendChild(section);
      return section;
    }

    // Update the image click handler to also update directory header state
    function addImageClickHandler(img, section) {
      img.addEventListener('click', function() {
        if (!this.classList.contains('selected')) {
          this.classList.add('selected');
          selectedImages.push(this.src);
        } else {
          this.classList.remove('selected');
          selectedImages = selectedImages.filter(s => s !== this.src);
        }
        updateDirectoryHeaderState(section);
        updateClearButtonStates();
      });
    }

    // Clear selection function
    function clearSelection() {
      document.querySelectorAll('.image-option').forEach(img => {
        img.classList.remove('selected');
      });
      selectedImages = [];

      // Update all directory headers
      document.querySelectorAll('.directory-section').forEach(section => {
        updateDirectoryHeaderState(section);
      });

      updateClearButtonStates();
    }

    // Randomize selection function
    function randomizeSelection() {
      // Clear current selection first
      clearSelection();
      
      // Get all available images
      const images = Array.from(document.querySelectorAll('.image-option'));
      if (images.length === 0) return;
      
      // Select random number of images (between 1 and 20% of total)
      const maxImages = Math.max(Math.floor(images.length * 0.2), 1);
      const numToSelect = Math.floor(Math.random() * maxImages) + 1;
      
      // Create array of indices and shuffle it
      const indices = Array.from({ length: images.length }, (_, i) => i);
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      
      // Select the first numToSelect images
      for (let i = 0; i < numToSelect; i++) {
        const img = images[indices[i]];
        img.classList.add('selected');
        selectedImages.push(img.src);
      }
      
      // Update button states and cursor preview
      updateClearButtonStates();
      if (document.body.classList.contains('canvas-view')) {
        updateCursorPreview();
      }
    }

    // Function to update clear button states
    function updateClearButtonStates() {
      const clearSelectionBtn = document.getElementById('clearSelectionBtn');
      const startButton = document.getElementById('startButton');
      const clearButton = document.getElementById('clearButton');
      const saveButton = document.getElementById('saveButton');
      
      if (clearSelectionBtn) {
        clearSelectionBtn.disabled = selectedImages.length === 0;
      }
      if (startButton) {
        startButton.disabled = selectedImages.length === 0;
      }
      if (clearButton) {
        clearButton.disabled = !canvasHasContent;
      }
      if (saveButton) {
        saveButton.disabled = !canvasHasContent;
      }
    }

    // === CANVAS SETUP ===
    let canvas = null;  // Store canvas reference
    
    // Function to place image at specific coordinates
    function placeImage(x, y, useCurrentPreview = false) {
      const cursorImg = document.getElementById('cursorImage');
      const canvas = document.getElementById('paintCanvas');
      if (!canvas || !cursorImg) {
        // console.log('Missing canvas or cursor image');
        return;
      }
      
      // console.log('Placing image at:', x, y, 'useCurrentPreview:', useCurrentPreview);
      
      const context = canvas.getContext('2d', { willReadFrequently: true });
      const imgSrc = isImageLocked ? lockedImage : cursorImg.src;
      const tempImg = new Image();
      tempImg.crossOrigin = "anonymous";
      tempImg.src = imgSrc;

      tempImg.onload = () => {
        let scale, rotation, wobbleX, wobbleY;
        
        if (useCurrentPreview) {
          // Get current preview transform values
          const transform = cursorImg.style.transform;
          // console.log('Current transform:', transform);
          
          const scaleMatch = transform.match(/scale\(([\d.]+)\)/);
          const rotateMatch = transform.match(/rotate\(([-\d.]+)deg\)/);
          const translateMatch = transform.match(/translate\(calc\(-50% \+ ([-\d.]+)px\), calc\(-50% \+ ([-\d.]+)px\)\)/);
          
          scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
          rotation = rotateMatch ? parseFloat(rotateMatch[1]) : 0;
          wobbleX = translateMatch ? parseFloat(translateMatch[1]) : 0;
          wobbleY = translateMatch ? parseFloat(translateMatch[2]) : 0;
          
          // console.log('Extracted values:', { scale, rotation, wobbleX, wobbleY });
        } else {
          scale = scaleRange.min + Math.random() * (scaleRange.max - scaleRange.min);
          rotation = (Math.random() * 2 - 1) * maxRotation;
          wobbleX = (Math.random() - 0.5) * 2 * wobbleAmount;
          wobbleY = (Math.random() - 0.5) * 2 * wobbleAmount;
        }

        const drawX = x + wobbleX;
        const drawY = y + wobbleY;

        context.save();
        context.translate(drawX, drawY);
        context.rotate(rotation * Math.PI / 180);
        context.scale(scale, scale);
        context.drawImage(tempImg, -tempImg.width / 2, -tempImg.height / 2);
        context.restore();

        canvasHasContent = true;
        updateClearButtonStates();

        // Track the serial number
        updateSerialTracking(imgSrc);

        if (!isImageLocked && !useCurrentPreview) {
          updateCursorPreview(scale, rotation, null, true);
        }
      };
    }

    // Function to handle canvas resizing while preserving content
    function resizeCanvas() {
      const tempCanvas = document.createElement('canvas');
      const tempContext = tempCanvas.getContext('2d');
      
      // Copy current canvas content to temp canvas
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      tempContext.drawImage(canvas, 0, 0);
      
      // Resize main canvas
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Restore the content
      canvas.getContext('2d').drawImage(tempCanvas, 0, 0);
    }

    // Initialize canvas if it exists
    function initCanvas() {
      canvas = document.getElementById('paintCanvas');
      if (!canvas) return;
      
      const context = canvas.getContext('2d', { willReadFrequently: true });
      
      // Only set initial size if canvas is empty
      if (!canvas.width || !canvas.height) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      // Remove any existing click listeners
      canvas.removeEventListener('click', handleCanvasClick);
      // Add click handler
      canvas.addEventListener('click', handleCanvasClick);
    }

    // Separate function for canvas click handling
    function handleCanvasClick(e) {
      if (!isMouseDown && !isOverToolbar(e)) {
        const mouseX = e.clientX;
        const mouseY = e.clientY;
        // console.log('Canvas clicked at:', mouseX, mouseY);
        placeImage(mouseX, mouseY, true);
      }
    }

    // Function to check if a point is over the toolbar
    function isOverToolbar(e) {
      const toolbar = document.getElementById('toolbar');
      const rect = toolbar.getBoundingClientRect();
      return e.clientY <= rect.bottom;
    }

    // Wait for DOM to be fully loaded before initializing
    document.addEventListener('DOMContentLoaded', function() {
      const selector = document.getElementById('selector');
      const startButton = document.getElementById('startButton');
      const randomizeBtn = document.getElementById('randomizeBtn');
      const clearSelectionBtn = document.getElementById('clearSelectionBtn');
      const selectAllBtn = document.getElementById('selectAllBtn');
      const toggleSelectButton = document.getElementById('toggleSelectButton');
      const clearButton = document.getElementById('clearButton');
      const saveButton = document.getElementById('saveButton');
      const cursorImg = document.getElementById('cursorImage');
      canvas = document.getElementById('paintCanvas');

      // Initialize canvas if it exists
      if (canvas) {
        const context = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
      }

      // Event Listeners - only add if elements exist
      if (randomizeBtn) {
        // Remove any existing listeners first
        const newRandomizeBtn = randomizeBtn.cloneNode(true);
        randomizeBtn.parentNode.replaceChild(newRandomizeBtn, randomizeBtn);
        newRandomizeBtn.addEventListener('click', randomizeSelection);
      }
      if (clearSelectionBtn) {
        clearSelectionBtn.addEventListener('click', clearSelection);
      }
      if (toggleSelectButton) {
        toggleSelectButton.addEventListener('click', toggleViews);
      }
      if (clearButton) {
        clearButton.addEventListener('click', clearCanvas);
      }
      if (saveButton) {
        saveButton.addEventListener('click', saveCanvas);
      }
      if (startButton) {
        startButton.addEventListener('click', toggleViews);
      }
      if (selector) {
        selector.addEventListener('click', () => {
          setTimeout(updateClearButtonStates, 0);
        });
      }

      // Mouse event listeners
      document.addEventListener('mousedown', () => isMouseDown = true);
      document.addEventListener('mouseup', () => {
        isMouseDown = false;
        updateClearButtonStates();
      });

      document.addEventListener('mousemove', (e) => {
        const cursorImg = document.getElementById('cursorImage');
        if (!cursorImg) return;
        
        // Don't update cursor or draw if over toolbar
        if (isOverToolbar(e)) {
          cursorImg.style.display = 'none';
          return;
        }
        cursorImg.style.display = 'block';
        
        const mouseX = e.clientX;
        const mouseY = e.clientY;
        cursorImg.style.left = `${mouseX}px`;
        cursorImg.style.top = `${mouseY}px`;

        // Update cursor preview with all effects, and advance image during movement
        const previewScale = scaleRange.min + (Math.random() * (scaleRange.max - scaleRange.min));
        const previewRotation = (Math.random() * 2 - 1) * maxRotation;
        const previewWobble = (Math.random() - 0.5) * 2 * wobbleAmount;
        updateCursorPreview(previewScale, previewRotation, previewWobble, true);

        if (!isMouseDown || isOverToolbar(e)) return;
        placeImage(mouseX, mouseY, false);
      });

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (!cursorImg) return;

        if (e.key === 'l') {
          isImageLocked = !isImageLocked;
          if (isImageLocked) {
            lockedImage = cursorImg.src;
            cursorImg.title = 'Current image is locked (Press L to unlock)';
          } else {
            cursorImg.title = 'Press L to lock current image';
            updateCursorPreview();
          }
        }

        // Only process slider controls when in canvas view
        if (!document.body.classList.contains('canvas-view')) return;

        const step = 0.1;
        const rotationStep = 5;
        const wobbleStep = 5;

        switch (e.key.toLowerCase()) {
          case 'q':
            scaleRange.min = Math.max(0.1, Math.min(scaleRange.max, scaleRange.min + (e.shiftKey ? -step : step)));
            scaleMinInput.value = scaleRange.min; // Update slider position
            updateDisplayValues();
            // Update preview with new scale range
            const previewScaleQ = scaleRange.min + (Math.random() * (scaleRange.max - scaleRange.min));
            updateCursorPreview(previewScaleQ);
            break;
          case 'w':
            scaleRange.max = Math.max(scaleRange.min, Math.min(1, scaleRange.max + (e.shiftKey ? -step : step)));
            scaleMaxInput.value = scaleRange.max; // Update slider position
            updateDisplayValues();
            // Update preview with new scale range
            const previewScaleW = scaleRange.min + (Math.random() * (scaleRange.max - scaleRange.min));
            updateCursorPreview(previewScaleW);
            break;
          case 'a':
            maxRotation = Math.max(0, Math.min(180, maxRotation + (e.shiftKey ? -rotationStep : rotationStep)));
            rotationInput.value = maxRotation; // Update slider position
            updateDisplayValues();
            // Update preview with new rotation
            const previewRotation = (Math.random() * 2 - 1) * maxRotation;
            updateCursorPreview(null, previewRotation);
            break;
          case 's':
            wobbleAmount = Math.max(0, Math.min(100, wobbleAmount + (e.shiftKey ? -wobbleStep : wobbleStep)));
            wobbleInput.value = wobbleAmount; // Update slider position
            updateDisplayValues();
            // Update preview with new wobble
            const previewWobble = (Math.random() - 0.5) * 2 * wobbleAmount;
            updateCursorPreview(null, null, previewWobble);
            break;
        }
      });

      // Initialize display values
      updateDisplayValues();

      // Fetch images from server
      fetch('http://localhost:8000/images')
        .then(response => response.json())
        .then(images => {
          totalImages = Object.values(images).flat().length;
          
          Object.entries(images).forEach(([dir, files]) => {
            if (files.length > 0) {
              const section = createDirectorySection(dir);
              
              allFilenames = allFilenames.concat(files);
              files.forEach(file => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = file;
                img.classList.add('image-option');
                img.onload = updateLoadingProgress;
                img.onerror = updateLoadingProgress;
                
                // Create container for the image
                const container = document.createElement('div');
                container.className = 'image-container';
                
                // Add serial number display
                const serialNumber = document.createElement('div');
                serialNumber.className = 'serial-number';
                const filename = file.split('/').pop(); // Get just the filename
                serialNumber.textContent = extractSerialNumber(filename);
                
                container.appendChild(img);
                container.appendChild(serialNumber);
                
                // Add click handler with section reference
                addImageClickHandler(img, section);
                
                section.appendChild(container);
              });
            }
          });
        })
        .catch(error => {
          console.error('Error fetching images:', error);
          document.querySelector('.loading-text').textContent = 
            'Error loading images. Please make sure the server is running (python server.py)';
        });

      // Add JavaScript to create the third split element
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
            const target = mutation.target;
            if (target.classList.contains('selected') && !target.querySelector('span')) {
              const span = document.createElement('span');
              target.appendChild(span);
            } else if (!target.classList.contains('selected') && target.querySelector('span')) {
              target.querySelector('span').remove();
            }
          }
        });
      });

      document.querySelectorAll('.image-option').forEach(img => {
        observer.observe(img, { attributes: true });
      });

      // Hide loading overlay when everything is ready
      window.addEventListener('load', hideLoadingOverlay);

      // Add click handler for select all button
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', selectAllImages);
      }
    });

    function updateLoadingProgress() {
      loadedImages++;
      const progress = Math.round((loadedImages / totalImages) * 100);
      const loadingText = document.getElementById('loadingText');
      
      if (loadingText) {
        loadingText.textContent = `Loading images... ${progress}%`;
      }

      // When we reach 100%, show content behind the overlay
      if (progress === 100) {
        const selector = document.getElementById('selector');
        const toolbar = document.getElementById('toolbar');
        
        // Show content immediately
        selector.classList.add('loaded');
        toolbar.classList.add('loaded');
        
        // Force immediate opacity update
        requestAnimationFrame(() => {
          selector.style.opacity = '1';
          toolbar.style.opacity = '1';
        });

        // Start the countdown to hide the overlay
        const elapsedTime = Date.now() - loadingStartTime;
        const remainingTime = Math.max(0, DEBUG.minLoadingTime - elapsedTime);
        
        setTimeout(() => {
          const loadingOverlay = document.getElementById('loadingOverlay');
          loadingOverlay.style.opacity = '0';
          setTimeout(() => {
            loadingOverlay.style.display = 'none';
          }, 800);
        }, remainingTime);
      }
    }

    // === TOOLBAR CONTROLS ===
    const toolbar = document.getElementById('toolbar');
    const scaleMinInput = document.getElementById('scaleMin');
    const scaleMaxInput = document.getElementById('scaleMax');
    const rotationInput = document.getElementById('rotationRange');
    const wobbleInput = document.getElementById('wobbleRange');
    const randomCount = document.getElementById('randomCount');

    // Update display values
    function updateDisplayValues() {
      document.getElementById('scaleMinValue').textContent = scaleMinInput.value;
      document.getElementById('scaleMaxValue').textContent = scaleMaxInput.value;
      document.getElementById('rotationValue').textContent = rotationInput.value;
      document.getElementById('wobbleValue').textContent = wobbleInput.value;
    }

    // Event listeners for controls
    scaleMinInput.addEventListener('input', () => {
      scaleRange.min = parseFloat(scaleMinInput.value);
      updateDisplayValues();
    });

    scaleMaxInput.addEventListener('input', () => {
      scaleRange.max = parseFloat(scaleMaxInput.value);
      updateDisplayValues();
    });

    rotationInput.addEventListener('input', () => {
      maxRotation = parseInt(rotationInput.value);
      updateDisplayValues();
    });

    wobbleInput.addEventListener('input', () => {
      wobbleAmount = parseInt(wobbleInput.value);
      updateDisplayValues();
    });

    // Toggle between select and canvas views
    function toggleViews() {
      const selectorView = document.getElementById('selector');
      const canvasView = document.getElementById('canvasView');
      const startButton = document.getElementById('startButton');
      
      if (selectorView.style.display === 'none') {
        // Switch to selector view
        selectorView.style.display = 'flex';
        canvasView.style.display = 'none';
        startButton.textContent = 'RETURN TO CANVAS >';
        document.body.classList.remove('canvas-view');
      } else {
        // Switch to canvas view
        if (selectedImages.length === 0) {
          alert("Please select at least one image.");
          return;
        }
        selectorView.style.display = 'none';
        canvasView.style.display = 'flex';
        startButton.textContent = 'START SCATTERGRAM >';
        document.body.classList.add('canvas-view');
        
        // Initialize canvas if needed
        initCanvas();
        
        // Set initial cursor preview
        const cursorImg = document.getElementById('cursorImage');
        if (cursorImg && selectedImages.length > 0) {
          cursorImg.src = selectedImages[0];
          cursorImg.style.display = 'block';
          updateCursorPreview();
        }
      }
    }

    // Clear canvas function
    function clearCanvas() {
      const canvas = document.getElementById('paintCanvas');
      const context = canvas.getContext('2d', { willReadFrequently: true });
      context.clearRect(0, 0, canvas.width, canvas.height);
      canvasHasContent = false;
      usedSerials.clear();
      updateDebugOverlay();
      updateClearButtonStates();
      
      // Remove any stored canvas state
      canvas.removeAttribute('data-previous-state');
    }

    // Function to get next image and update cursor
    function updateCursorPreview(scale = null, rotation = null, wobble = null, advanceImage = false) {
      const cursorImg = document.getElementById('cursorImage');
      
      // Only change the image if we're not locked and explicitly asked to advance
      if (!isImageLocked && advanceImage && selectedImages.length > 0) {
        nextImageIndex = (nextImageIndex + 1) % selectedImages.length;
        cursorImg.src = selectedImages[nextImageIndex];
      } else if (isImageLocked && lockedImage) {
        cursorImg.src = lockedImage;
      } else if (!isImageLocked && selectedImages.length > 0 && !cursorImg.src) {
        // Initialize with first image if no image is set
        cursorImg.src = selectedImages[0];
      }
      
      // Calculate transform values
      const newScale = scale !== null ? scale : (scaleRange.min + Math.random() * (scaleRange.max - scaleRange.min));
      const newRotation = rotation !== null ? rotation : ((Math.random() * 2 - 1) * maxRotation);
      const wobbleX = wobble !== null ? wobble : ((Math.random() - 0.5) * 2 * wobbleAmount);
      const wobbleY = wobble !== null ? wobble : ((Math.random() - 0.5) * 2 * wobbleAmount);
      
      // Apply all transformations in the correct order
      cursorImg.style.transform = `translate(calc(-50% + ${wobbleX}px), calc(-50% + ${wobbleY}px)) rotate(${newRotation}deg) scale(${newScale})`;
      
      return cursorImg.src;
    }

    // Save canvas function
    async function saveCanvas() {
      const canvas = document.getElementById('paintCanvas');
      const tempCanvas = document.createElement('canvas');
      const ctx = tempCanvas.getContext('2d');
      const serials = getUniqueSerials();
      
      // Get sequence number from server or use timestamp if server fails
      let sequenceNum;
      try {
          const serialCounts = countSerialUsage();
          const serialUsageData = Object.entries(serialCounts).map(([serial, count]) => ({
              serial,
              count
          }));

          const response = await fetch('http://localhost:8000/api/track-usage', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                  userAgent: navigator.userAgent,
                  totalPlacements: document.querySelectorAll('.placed-image').length,
                  uniqueSerials: serials.length,
                  browser: navigator.userAgent.match(/chrome|firefox|safari|edge|opera/i)?.[0] || 'unknown',
                  platform: navigator.platform,
                  serialUsage: serialUsageData
              })
          });
          
          if (!response.ok) {
              throw new Error(`Server returned ${response.status}`);
          }

          const result = await response.json();
          if (!result.success) {
              throw new Error(result.message || 'Failed to track usage');
          }

          sequenceNum = String(result.sequenceNumber).padStart(3, '0');
      } catch (error) {
          console.warn('Failed to get sequence number from server:', error);
          sequenceNum = new Date().getTime().toString().slice(-3);
      }

      // Set up the canvas with watermark
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      
      // Draw the main canvas content
      ctx.drawImage(canvas, 0, 0);
      
      // Prepare the text content
      const now = new Date();
      const timestamp = `${now.getMonth() + 1}/${now.getDate()}/${now.getFullYear()} @ ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()} (#${sequenceNum}) with: `;
      
      // Set up text properties
      ctx.font = '14px "OCR A Std"';
      const padding = 10;
      const lineHeight = 20;
      const maxWidth = tempCanvas.width - (padding * 2);
      
      // Split text into sections for different colors
      const brandText = 'SCATTERGRAPH 3.0';
      const separator = ' • ';
      const urlText = 'thfnul.com';
      const contentText = `Created on ${timestamp}${serials.join(', ')}`;
      
      // Calculate wrapped lines
      const lines = [];
      
      // First line starts with branding
      let firstLine = '';
      let remainingWords = contentText.split(' ');
      
      // Add words to the first line until we hit maxWidth
      ctx.fillStyle = '#12e2dc'; // Temporarily set to measure text width
      let brandingWidth = ctx.measureText(`${brandText}${separator}${urlText}${separator}`).width;
      let x = padding + brandingWidth;
      let currentLine = '';
      
      while (remainingWords.length > 0 && 
             ctx.measureText(currentLine + ' ' + remainingWords[0]).width + brandingWidth < maxWidth - padding * 2) {
        currentLine += (currentLine ? ' ' : '') + remainingWords.shift();
      }
      
      // First line combines branding and start of content
      lines.push({
        branding: true,
        text: currentLine
      });
      
      // Wrap remaining words
      currentLine = '';
      while (remainingWords.length > 0) {
        let word = remainingWords[0];
        let testLine = currentLine ? `${currentLine} ${word}` : word;
        
        if (ctx.measureText(testLine).width > maxWidth - padding * 2 && currentLine !== '') {
          lines.push({
            branding: false,
            text: currentLine
          });
          currentLine = word;
          remainingWords.shift();
        } else {
          currentLine = testLine;
          remainingWords.shift();
        }
      }
      
      if (currentLine) {
        lines.push({
          branding: false,
          text: currentLine
        });
      }
      
      // Calculate total height needed for watermark
      const totalHeight = lines.length * lineHeight + (padding * 2);
      
      // Draw background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, tempCanvas.height - totalHeight, tempCanvas.width, totalHeight);
      
      // Draw each line
      lines.forEach((line, index) => {
        let x = padding;
        const y = tempCanvas.height - totalHeight + padding + (lineHeight * index) + lineHeight - 4;
        
        if (line.branding) {
          // Draw branding section
          ctx.fillStyle = '#ece83e'; // Volt yellow
          ctx.fillText(brandText, x, y);
          x += ctx.measureText(brandText).width;
          
          ctx.fillStyle = '#ffffff';
          ctx.fillText(separator, x, y);
          x += ctx.measureText(separator).width;
          
          ctx.fillStyle = '#ef3b39'; // Red
          ctx.fillText(urlText, x, y);
          x += ctx.measureText(urlText).width;
          
          ctx.fillStyle = '#ffffff';
          ctx.fillText(separator, x, y);
          x += ctx.measureText(separator).width;
          
          // Draw the content portion of the first line
          ctx.fillStyle = '#12e2dc';
          ctx.fillText(line.text, x, y);
        } else {
          // Draw subsequent lines in teal
          ctx.fillStyle = '#12e2dc';
          ctx.fillText(line.text, x, y);
        }
      });
      
      // Save the image
      try {
          const link = document.createElement('a');
          link.download = `scattergraph-${sequenceNum}.png`;
          link.href = tempCanvas.toDataURL('image/png');
          link.click();
      } catch (error) {
          console.error('Error saving canvas:', error);
          alert('Failed to save the canvas. Please try again.');
      }
    }

    // Function to extract serial number from filename
    function extractSerialNumber(filename) {
      // Remove file extension and get last 8 characters
      const withoutExtension = filename.replace(/\.png$/, '');
      return withoutExtension.slice(-8);
    }

    // Function to update serial tracking
    function updateSerialTracking(imgSrc, isAdding = true) {
      const filename = imgSrc.split('/').pop();
      const serial = extractSerialNumber(filename);
      
      if (isAdding) {
        if (DEBUG.trackInstanceCount) {
          usedSerials.set(serial, (usedSerials.get(serial) || 0) + 1);
        } else {
          usedSerials.set(serial, 1);
        }
      }
      
      updateDebugOverlay();
    }

    // Function to get unique serials from usedSerials Map
    function getUniqueSerials() {
      return Array.from(usedSerials.keys());
    }

    // Function to count serial usage
    function countSerialUsage() {
      return Object.fromEntries(usedSerials);
    }

    // Function to update debug overlay
    function updateDebugOverlay() {
      if (!DEBUG.showSerialOverlay) return;

      const overlay = document.getElementById('serialOverlay');
      if (!overlay) return; // Guard against missing overlay
      
      const pre = overlay.querySelector('pre');
      if (!pre) return; // Guard against missing pre element
      
      if (usedSerials.size === 0) {
        pre.textContent = 'No serials used in current canvas';
      } else {
        const serialList = Array.from(usedSerials.entries())
          .sort(([a], [b]) => a.localeCompare(b))
          .map(([serial, count]) => 
            DEBUG.trackInstanceCount ? 
              `${serial}: ${count}x` : 
              serial
          );
        
        pre.textContent = `Serials used in current canvas:\n${serialList.join(', ')}`;
      }
      
      overlay.classList.add('visible');
    }

    function hideLoadingOverlay() {
      const loadingOverlay = document.getElementById('loadingOverlay');
      const loadingContainer = document.querySelector('.loading-container');
      
      // If in debug mode, hide immediately
      if (DEBUG.skipLoadingAnimation) {
        loadingOverlay.style.display = 'none';
        return;
      }

      // Start the wave animation after the specified delay
      setTimeout(() => {
        loadingContainer.classList.add('animate');
      }, DEBUG.animationStartDelay);

      // Calculate how long we've been loading
      const elapsedTime = Date.now() - loadingStartTime;
      const remainingTime = Math.max(0, DEBUG.minLoadingTime - elapsedTime);

      // Wait for minimum time before hiding
      setTimeout(() => {
        loadingOverlay.style.opacity = '0';
        setTimeout(() => {
          loadingOverlay.style.display = 'none';
        }, 800);
      }, remainingTime);
    }
  </script>
</body>
</html>
